def foobar(n):
	# this is perhaps the most common coding intervieew question still in use today. 
	# people use it to just test if people are bullshitting about being able to code
	# So don't over think it it's not supposed to be complicated, you just want to write
	# something simple and clean

	# The goal is to return the string 'foo' if a number is divisible by 3, return the string 'bar'
	# if the number is divisible by 5, and return the string 'foobar' if thhe number is divisible by
	# both 3 AND 5, and return False otherwise
	pass


def bridges(islands, bridges):
	# this is an implementation of the Bridges of Konigsberg problem.  Don't be intimidated by this one
	# if you don't just think of an answer, it's legitimately a hard problem, it's a problem
	# Euler figured out over a few days, which would mean it would be pretty ridiculous to expect
	# a mortal to do it, except for the fact you get something Euler didn't have: A computer

	# It goes like this.  There are 4 islands, and seven bridges, each bridge connecting some island to another
	# can you write a program to verify if it's possible to walk these bridges, each once, but NEVER more than once
	# and ending on the island you started.  The test will include the arrangement of bridges in the original 
	# famous problem, but naturally the goal will be to write a program that could solve it for many setups
	# just return true or false, about whether it can be done

	pass


def symbolic_polynomial_differentiation(p):
	''' I don't know anyone who hasn't given this a shot at some point, but it's a lot harder than it looks.  Like the above
		one just look to make progress, handle a few cases.  It's going to take a string and return a string
	'''
	pass